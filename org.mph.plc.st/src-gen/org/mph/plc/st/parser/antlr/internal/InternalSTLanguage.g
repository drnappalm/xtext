/*
* generated by Xtext
*/
grammar InternalSTLanguage;

options {
	superClass=AbstractInternalAntlrParser;
	
}

@lexer::header {
package org.mph.plc.st.parser.antlr.internal;

// Hack: Use our own Lexer superclass by means of import. 
// Currently there is no other way to specify the superclass for the lexer.
import org.eclipse.xtext.parser.antlr.Lexer;
}

@parser::header {
package org.mph.plc.st.parser.antlr.internal; 

import org.eclipse.xtext.*;
import org.eclipse.xtext.parser.*;
import org.eclipse.xtext.parser.impl.*;
import org.eclipse.emf.ecore.util.EcoreUtil;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.xtext.parser.antlr.AbstractInternalAntlrParser;
import org.eclipse.xtext.parser.antlr.XtextTokenStream;
import org.eclipse.xtext.parser.antlr.XtextTokenStream.HiddenTokens;
import org.eclipse.xtext.parser.antlr.AntlrDatatypeRuleToken;
import org.mph.plc.st.services.STLanguageGrammarAccess;

}

@parser::members {

 	private STLanguageGrammarAccess grammarAccess;
 	
    public InternalSTLanguageParser(TokenStream input, STLanguageGrammarAccess grammarAccess) {
        this(input);
        this.grammarAccess = grammarAccess;
        registerRules(grammarAccess.getGrammar());
    }
    
    @Override
    protected String getFirstRuleName() {
    	return "POU";	
   	}
   	
   	@Override
   	protected STLanguageGrammarAccess getGrammarAccess() {
   		return grammarAccess;
   	}
}

@rulecatch { 
    catch (RecognitionException re) { 
        recover(input,re); 
        appendSkippedTokens();
    } 
}




// Entry rule entryRulePOU
entryRulePOU returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getPOURule()); }
	 iv_rulePOU=rulePOU 
	 { $current=$iv_rulePOU.current; } 
	 EOF 
;

// Rule POU
rulePOU returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
(
(
		{ 
	        newCompositeNode(grammarAccess.getPOUAccess().getBodyPOU_BODYParserRuleCall_0()); 
	    }
		lv_body_0_0=rulePOU_BODY		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getPOURule());
	        }
       		set(
       			$current, 
       			"body",
        		lv_body_0_0, 
        		"POU_BODY");
	        afterParserOrEnumRuleCall();
	    }

)
)
;





// Entry rule entryRulePOU_BODY
entryRulePOU_BODY returns [EObject current=null] 
	:
	{ newCompositeNode(grammarAccess.getPOU_BODYRule()); }
	 iv_rulePOU_BODY=rulePOU_BODY 
	 { $current=$iv_rulePOU_BODY.current; } 
	 EOF 
;

// Rule POU_BODY
rulePOU_BODY returns [EObject current=null] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
(
(
		{ 
	        newCompositeNode(grammarAccess.getPOU_BODYAccess().getElementsBODY_ELEMENTParserRuleCall_0()); 
	    }
		lv_elements_0_0=ruleBODY_ELEMENT		{
	        if ($current==null) {
	            $current = createModelElementForParent(grammarAccess.getPOU_BODYRule());
	        }
       		add(
       			$current, 
       			"elements",
        		lv_elements_0_0, 
        		"BODY_ELEMENT");
	        afterParserOrEnumRuleCall();
	    }

)
)
;





// Entry rule entryRuleBODY_ELEMENT
entryRuleBODY_ELEMENT returns [String current=null] 
	:
	{ newCompositeNode(grammarAccess.getBODY_ELEMENTRule()); } 
	 iv_ruleBODY_ELEMENT=ruleBODY_ELEMENT 
	 { $current=$iv_ruleBODY_ELEMENT.current.getText(); }  
	 EOF 
;

// Rule BODY_ELEMENT
ruleBODY_ELEMENT returns [AntlrDatatypeRuleToken current=new AntlrDatatypeRuleToken()] 
    @init { enterRule(); 
    }
    @after { leaveRule(); }:
(    this_COMMENT_0=RULE_COMMENT    {
		$current.merge(this_COMMENT_0);
    }

    { 
    newLeafNode(this_COMMENT_0, grammarAccess.getBODY_ELEMENTAccess().getCOMMENTTerminalRuleCall_0()); 
    }

    |    this_PRAGMA_1=RULE_PRAGMA    {
		$current.merge(this_PRAGMA_1);
    }

    { 
    newLeafNode(this_PRAGMA_1, grammarAccess.getBODY_ELEMENTAccess().getPRAGMATerminalRuleCall_1()); 
    }

    |    this_IDENTIFIER_2=RULE_IDENTIFIER    {
		$current.merge(this_IDENTIFIER_2);
    }

    { 
    newLeafNode(this_IDENTIFIER_2, grammarAccess.getBODY_ELEMENTAccess().getIDENTIFIERTerminalRuleCall_2()); 
    }
)
    ;





RULE_PRAGMA : '{' ~('{')* '}';

RULE_COMMENT : '(*' ~('(*')* '*)';

RULE_IDENTIFIER : '^'? (RULE_LETTER|RULE_UNDERSCORE) ~(RULE_UNDERSCORE) (RULE_LETTER|RULE_DIGIT|RULE_UNDERSCORE)* ~(RULE_UNDERSCORE);

fragment RULE_CHARACTER : (RULE_LETTER|RULE_DIGIT|RULE_SYMBOL|RULE_UNDERSCORE)*;

fragment RULE_LETTER : ('a'..'z'|'A'..'Z');

fragment RULE_DIGIT : '0'..'9';

fragment RULE_SYMBOL : (' '|'!'|'"'|'%'|'&'|'\''|'('|')'|'*'|'+'|','|'-'|'.'|'/'|':'|';'|'<'|'='|'>'|'?'|'#'|'\u00A3'|'$'|'|');

fragment RULE_UNDERSCORE : '_';


